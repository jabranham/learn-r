#+TITLE:     Introduction to Data Analysis and Reporting with R
#+AUTHOR:    J. Alexander Branham
#+EMAIL:     branham@utexas.edu
#+DATE:      June 2017
#+startup: beamer
#+LaTeX_CLASS: beamer
#+LATEX_COMPILER: xelatex
#+OPTIONS: toc:nil H:2
#+LATEX_HEADER: \beamerdefaultoverlayspecification{<+->}
#+LATEX_HEADER: \usepackage[newfloat]{minted}
#+LATEX_CLASS_OPTIONS: [colorlinks, urlcolor=blue, aspectratio=169]
#+PROPERTY: header-args:R :session *R*
#+BEAMER_THEME: metropolis[titleformat=smallcaps, progressbar=frametitle]
#+BEGIN_SRC R :exports none
  dir.create("figures/", showWarnings = FALSE)
#+END_SRC

* Course Information
** Course Information
- We'll cover tools that should be helpful in nearly any analysis
  - Graphing, data manipulation, etc
- We won't cover specialized, specific tools. But you should get a good enough understanding of how R works to be able to teach yourself these
** Outline
- TODO
* What is R?
** What is R?
- This is a course about R...  /mais qu'est-ce que c'est/?
- "R is a language and environment for statistical computing and graphics"
- Derived from S, designed at Bell Laboratories
  - S first appeared in 1976!
- /R is a language/ ... so be prepared for it to hurt a bit to learn!
** Advantages of R
- Free
- Open-source
- Available on nearly every platform
- Extensible via *packages* --- CRAN has over 10,000
- Great community
** Running code
- How to use this R thing?
- If you have R and Rstudio installed, open Rstudio.
- You should see three panes.
- We'll focus for now on the console, which is on the left and should look something like this:
** 
#+BEGIN_EXAMPLE
  R version 3.4.0 (2017-06-15) -- "You Stupid Darkness"
  Copyright (C) 2017 The R Foundation for Statistical Computing
  Platform: x86_64-pc-linux-gnu (64-bit)

  [ ... ]

  Type 'demo()' for some demos, 'help()' for on-line help, or
  'help.start()' for an HTML browser interface to help.
  Type 'q()' to quit R.
#+END_EXAMPLE
** R is a big giant calculator
- R can do math
- Really, really fancy math
- Try typing =3 + 3= in the console
- After pressing enter, R will return =6=
- R understands the order of operations 
  - =3 + 3 * 9= is different from =(3 + 3) * 9=
** A quiz
- Time for a quiz!
- What's 7 times 149?
- What's the square root of the previous answer?
- *Tip:* You can hit the up arrow to get whatever you entered last
** Answers
#+BEGIN_SRC R :exports both :results output
7 * 149
#+END_SRC

#+BEGIN_SRC R :exports both :results output
(7 * 149) ^ (1 / 2)
#+END_SRC
** Packages
- At this point, please install a few packages. You'll need an internet connection.
- =install.packages(c("tidyverse", "gapminder"))=
  - If you have already installed some packages, make sure they're up-to-date:
    - =update.packages()=
- *Tip:* just type =ins= then hit TAB for tab-completion
- Don't worry about what is going on here, I'll explain it later.
- Depending on your exact setup, R may ask you a few questions about using a personal library. Do so.
- If you get an error, make sure you can access the internet (https://cloud.r-project.org in particular)
** R scripts
- While those packages are installing, let's go ahead and open up an R script.
- Allows you to save code so it doesn't disappear into the ether
- If using Rstudio, File, new file, R script (or Ctrl+shift+n)
- *Tip*: can send a line from R script to console for evaluation using ctrl+enter
- *Strongly recommend* that you type into a script and use a keyboard shortcut to evaluate code
  - Easier to edit & rerun
  - Allows you to save code
  - You may make comments
#+BEGIN_SRC R :eval no
  ## This adds 3 + 3
  3 + 3
  3 * 2 # same
#+END_SRC

* Graphics in R
** Data Analysis with R
- Let's take a look at some data.
- We're going to use some data that comes with the =gapminder= package you just installed
- To access the data, you need to load it into memory:
#+BEGIN_SRC R
library(gapminder)
#+END_SRC
** Exploring our data
- =gapminder= is a *data.frame*
- Can get a sense of what it looks like with some *functions*
- Let's get a sense of what =gapminder= has:
#+BEGIN_SRC R :eval no
  View(gapminder)
#+END_SRC
#+BEGIN_SRC R :exports both :results output
head(gapminder)
#+END_SRC
** Descriptive statistics
- R has lots of built-in functions for getting a sense of the data.
- Try running =summary(gapminder)=
- What's the average life expectancy?
\pause
#+BEGIN_SRC R :exports both :results output
summary(gapminder)
#+END_SRC
** Graphics in R
- Let's start making graphs
- This is the fun part!
- We're going to rely on the `ggplot2` package, which we installed earlier (as a part of the tidyverse package)
- "The Grammar of Graphics"
- load it up with
#+BEGIN_SRC R
library(ggplot2)
#+END_SRC
** Our question
#+BEGIN_QUOTE
What's the relationship between wealth (gdp) and average life expectancy?
#+END_QUOTE
- Scatterplot is a good way to get started looking at data!
** ggplot2
- Use the =ggplot()= function to start a plot.
- The first /argument/ is to tell it the /data/
- *Tip:* use =?ggplot= to look at the help page, where you can see the names of the arguments
\pause
#+BEGIN_SRC R :eval no
  ggplot(data = gapminder) # Please use gapminder data
#+END_SRC
** =geom_point=
- =ggplot()= by itself is pretty useless, it just starts a plot
- We then have to tell =ggplot= what to draw!
- *Tip:* =?geom_point=
\pause
#+BEGIN_SRC R
    ggplot(data = gapminder) +
      geom_point(mapping = aes(x = gdpPercap, # Put gdp on x axis
                               y = lifeExp))  # Put lifeExp on y

#+END_SRC
#+BEGIN_SRC R :exports none
  ggsave("figures/gdp-life.pdf",
         width = 9,
         height = 6.5)
#+END_SRC

** 
#+ATTR_LATEX: :float t :width 0.8\textwidth
[[file:figures/gdp-life.pdf]]
** Fix that x axis!

#+BEGIN_SRC R
  ggplot(data = gapminder) +
    geom_point(mapping = aes(x = log(gdpPercap), # Log x-axis
                             y = lifeExp))
#+END_SRC
#+BEGIN_SRC R :exports none
  ggsave("figures/gdp-life-logx.pdf", width = 9, height = 6.5)
#+END_SRC
** 
#+ATTR_LATEX: :float t :width 0.8\textwidth
[[file:figures/gdp-life-logx.pdf]]
** Aesthetics
- =ggplot()= creates a coordinate system
- You can then add one or more layers to this to create a plot
- We just added the =geom_point()= layer, which used the =x= and =y= aesthetics (=aes=) to add a layer of points to our plot
- We can add more information to the aesthetics to convey more information like color, shape, and size.
- Example: What if we want to convey info about relationship between wealth and life expectancy by continent?
- One solution: add color by continent
** Color 
#+BEGIN_SRC R
  ggplot(data = gapminder) +
    geom_point(mapping = aes(x = log(gdpPercap),
                             y = lifeExp,
                             ## colour for the Brits
                             color = continent)) 
#+END_SRC
#+BEGIN_SRC R :exports none
  ggsave("figures/gdp-life-continent-color.pdf",
         width = 9,
         height = 6.5)
#+END_SRC
** 
#+ATTR_LATEX: :float t :width 0.8\textwidth
[[file:figures/gdp-life-continent-color.pdf]]
** Multiple aesthetics - color & shape
- Of course, some people are colorblind, and others don't print things in color, so may be nice to use something like shape in addition:

#+BEGIN_SRC R
  ggplot(gapminder) +
    geom_point(aes(x = log(gdpPercap),
                   y = lifeExp,
                   color = continent, 
                   shape = continent))
#+END_SRC
#+BEGIN_SRC R :exports none
  ggsave("figures/gdp-life-continent-shape.pdf",
         width = 9,
         height = 6.5)
#+END_SRC
** 
#+ATTR_LATEX: :float t :width 0.8\textwidth
[[file:figures/gdp-life-continent-shape.pdf]]
** More about aesthetics
- There are more aesthetic mappings
- Try =size=, and =alpha= (transparency) for yourself
- You can set aesthetics directly by mapping the aesthetic to a value /outside the call to aes()/ 
- For example, we may want to make the dots slightly transparent to avoid overplotting
** Aesthetics not mapped to variable
#+BEGIN_SRC R
  ggplot(data = gapminder) +
    geom_point(mapping = aes(x = log(gdpPercap),
                             y = lifeExp,
                             color = continent),
               alpha = 0.5)
#+END_SRC
#+BEGIN_SRC R :exports none
  ggsave("figures/gdp-life-transparent.pdf",
         width = 9,
         height = 6.5)
#+END_SRC

** 
#+ATTR_LATEX: :float t :width 0.8\textwidth
[[file:figures/gdp-life-transparent.pdf]]

** Facets
- So we can use aesthetics to add variables to our graph like =color=. 
- We might also want to add variables by splitting up the graph based on values of another variables --- e.g. subfigures
- If we want to use just one variable, use =facet_wrap()=
\pause
#+BEGIN_SRC R
  ggplot(data = gapminder) +
    geom_point(mapping = aes(x = log(gdpPercap),
                             y = lifeExp)) +
    facet_wrap( ~ continent, nrow = 2)
#+END_SRC
#+BEGIN_SRC R :exports none
  ggsave("figures/gdp-life-facet-continent.pdf",
         width = 9,
         height = 6.5)
#+END_SRC
** 
#+ATTR_LATEX: :float t :width 0.8\textwidth
[[file:figures/gdp-life-facet-continent.pdf]]
** Facets with two variables
- ggplot can facet with two variables with one by row and the other by column
- Use =facet_grid(row ~ column)= to do so
- Our =gapminder= data aren't very well suited for this, but you could do something like:
\pause
 #+BEGIN_SRC R
   ggplot(data = gapminder) +
     geom_point(mapping = aes(x = log(gdpPercap),
                              y = lifeExp)) +
     ## year >= 2000 will be TRUE or FALSE; 
     ## we'll learn more about logical statements later on:
     facet_grid(year >= 2000 ~ continent)  
#+END_SRC
#+BEGIN_SRC R :exports none
   ggsave("figures/gdp-life-facet-continent-post2000.pdf",
          width = 9,
          height = 6.5)
#+END_SRC
** 
#+ATTR_LATEX: :float t :width 0.8\textwidth
[[file:figures/gdp-life-facet-continent-post2000.pdf]]
** ggplot
- Review of what we've learned so far:
  - =ggplot()= creates a blank coordinate system
  - =aes()= helps us map variables to visual properties (x/y location, color, shape, etc)
  - =facet_wrap()= and =facet_grid()= help us convey variables via subfigures
- But what about plots other than the scatterplot?
** geoms
- A =geom= (geometrical object) is =ggplot='s way of representing data
- We've been using =geom_point()= to represent data as points, e.g. a scatterplot
- A =geom= is (usually) the thing we call the plot - line plots, bar plots, boxplots, etc
- Let's plot the same relationship between wealth and life expectancy but using =geom_smooth()= rather than =geom_point()=:
\pause
#+BEGIN_SRC R
  ggplot(data = gapminder) +
    geom_smooth(mapping = aes(x = log(gdpPercap),
                              y = lifeExp)) 

#+END_SRC
#+BEGIN_SRC R :exports none
  ggsave("figures/gdp-life-smooth.pdf",
         width = 9,
         height = 6.5)
#+END_SRC
** 
#+ATTR_LATEX: :float t :width 0.8\textwidth
[[file:figures/gdp-life-smooth.pdf]]
** geoms and aesthetics
- Note that different aesthetics are available for different geoms
- So while =linetype= didn't really make sense for our scatterplot, it makes total sense for a line:
\pause
#+BEGIN_SRC R
  ggplot(data = gapminder) +
    geom_smooth(mapping = aes(x = log(gdpPercap),
                              y = lifeExp,
                              linetype = continent)) 

#+END_SRC
#+BEGIN_SRC R :exports none
  ggsave("figures/gdp-life-smooth-continent.pdf",
         width = 9,
         height = 6.5)
#+END_SRC
** 
#+ATTR_LATEX: :float t :width 0.8\textwidth
[[file:figures/gdp-life-smooth-continent.pdf]]
** multiple geoms
- To add multiple geoms, just add them one after the other:
\pause
#+BEGIN_SRC R
  ggplot(data = gapminder) +
    geom_smooth(mapping = aes(x = log(gdpPercap),
                              y = lifeExp)) +
    geom_point(mapping = aes(x = log(gdpPercap),
                             y = lifeExp))


#+END_SRC
#+BEGIN_SRC R :exports none
  ggsave("figures/gdp-life-smooth-point.pdf",
         width = 9,
         height = 6.5)
#+END_SRC
** 
#+ATTR_LATEX: :float t :width 0.8\textwidth
[[file:figures/gdp-life-smooth-point.pdf]]
** inherit aes
- Instead of retyping the =aes= mapping, we can specify a set of defaults in the =ggplot()= call, and overwrite (or add) then in each =geom= call:
\pause
#+BEGIN_SRC R
  ggplot(data = gapminder,
         mapping = aes(x = log(gdpPercap),
                       y = lifeExp)) +
    geom_smooth() +
    geom_point(mapping = aes(color = continent))
#+END_SRC
#+BEGIN_SRC R :exports none
  ggsave("figures/gdp-life-smooth-point-color.pdf",
         width = 9,
         height = 6.5)
#+END_SRC
** 
#+ATTR_LATEX: :float t :width 0.8\textwidth
[[file:figures/gdp-life-smooth-point-color.pdf]]
* Basic R
** Basics
- We skipped all of this because plotting is more fun & I wanted to start with something fun 
- Let's talk about basic R
** Calculator
- Remember R can be a calculator:
#+BEGIN_SRC R :exports both :results output
  3 * 3 + 29 ^ 4 + 7
#+END_SRC
- But R doesn't "remember" the answer to that anywhere
- You must /assign/ the output to an object in order for R to remember it:
#+BEGIN_SRC R
  x <- 3 * 3 + 29 ^ 4 + 7
  my_name <- "Alex Branham"
#+END_SRC
** Wait, what?
- Yeah, I just assigned letters to an object
- We can inspect the contents of an object by typing it into the R console:
#+BEGIN_SRC R :exports both :results output
  x
#+END_SRC
- Here, type =my_= then hit tab to have autocompletion
#+BEGIN_SRC R :exports both :results output
  my_name
#+END_SRC
** +
- If you forgot the closing ="= ---  =my_name <- "Alex Branham=
- The R prompt will change from =>= to =+=
- This indicates that R is waiting for you.
- Cancel by mashing ~ESC~
** R is pedantic
- You have to be really specific with R:
#+BEGIN_SRC R :exports both :results output
x
#+END_SRC
#+BEGIN_SRC R :exports both :results output
X
#+END_SRC
#+BEGIN_SRC R :exports both :results output
my_nam
#+END_SRC
** Things don't happen magically
#+BEGIN_SRC R :exports both :results output
x
#+END_SRC
#+BEGIN_SRC R :exports both :results output
x / 1000
#+END_SRC
#+BEGIN_SRC R :exports both :results output
x
#+END_SRC
** Missing values
- Missing data is represented by =NA= in R
- R thinks about this as "something that's there, but whose value we do not know"
- Missingness propagates
\pause
#+BEGIN_SRC R :exports both :results output
  mean(c(1, 2, NA))
#+END_SRC
** Missingness quiz
What will be the result?
#+BEGIN_SRC R :eval no
  3 == NA
  NA == NA
#+END_SRC
** Missingness quiz answer
#+BEGIN_SRC R :exports both :results output
  3 == NA
#+END_SRC
#+BEGIN_SRC R :exports both :results output
  NA == NA
#+END_SRC
** Functions
- Functions in R can take zero or more arguments
#+BEGIN_EXAMPLE
  function(arg1 = object1, arg2 = object2, arg3 = object3)
#+END_EXAMPLE
#+BEGIN_SRC R :exports both :results output
  my_vector <- seq(from = 1, to = 10, by = 1)
  my_vector
#+END_SRC
#+BEGIN_SRC R :exports both :results output
  mean(x = my_vector)
#+END_SRC
** Functions, continued
#+BEGIN_SRC R :exports both :results output
  my_vector <- c(1, 2, 3, NA, NA, NA, 3, 2, 1)
  mean(x = my_vector)
#+END_SRC
\pause
#+BEGIN_SRC R :exports both :results output
  mean(x = my_vector, na.rm = TRUE)
#+END_SRC
** Function arguments
- You don't have to specify argument names if you type them in order.
- Since =x= is the first argument of =mean()=, no need to type =mean(x = my_vector)=
- Instead, can just type =mean(my_vector)=
- This cuts down on the amount you have to type
** Data
- OK, so now we know how to assign stuff and functions
- Let's learn about how R thinks about data
  - "data" here doesn't have to mean data from e.g. a survey
- R cares about the *class* (type) of data and its *dimension(s)*
** Data types
- We'll discuss the four most common data types:
  - Numeric
  - Logical
  - Character
  - Factor
- We'll also cover =NA=
** Numeric
- Numeric is how R thinks about numbers!
- These can also be called "integer" (if round numbers) or "double"
#+BEGIN_SRC R :exports both :results output
  class(c(1, 2, 3))
#+END_SRC
#+BEGIN_SRC R :exports both :results output
  sum(c(1, 2, 3))
#+END_SRC
#+BEGIN_SRC R :exports both :results output
  class(sum(c(1, 2, 3)))
#+END_SRC
** Logical
- Logical can take two values --- =TRUE= or =FALSE=
- This is useful for dummy variables and tests
#+BEGIN_SRC R :exports both :results output
  1:10 > 5
#+END_SRC
** Character
- Characters represent text
- Sometimes these are called "strings"
#+BEGIN_SRC R
  c("This", "vector", "is", "of", "length", "what?")
  c("How about this one?")
#+END_SRC
** Factor
- Factors are how R thinks about categorical variables
- We already worked with these when we used the =continent= variable from =gapminder=
#+BEGIN_SRC R :exports both :results output
  head(gapminder$continent)
#+END_SRC

** Data dimensions
What's the difference?
#+BEGIN_SRC R :results output :exports results
  c(1, 2, 3, 4, 5, 6)
#+END_SRC
#+BEGIN_SRC R :results output :exports results
  matrix(c(1, 2, 3, 4, 5, 6), nrow = 3)
#+END_SRC
- Data can have *dimensions*
- Numeric, logical, character, and factors are single dimensions (so are lists)
- That matrix is a 3 by 2 matrix
- Why might we want to have two-dimensional data?
- Matrices must have the same type, but we can mix and match types with a =data.frame=
** The data.frame
- Remember =gapminder= from earlier?
- We used a =data.frame= to store columns with different data types
- We can access (index) =data.frame= objects using notation similar to matrix notation
#+BEGIN_SRC R :eval no
  gapminder[2, 1] # get whatever is in the second row, 1st col
  gapminder[1, ]  # get the first col (all)
  gapminder[, 1]  # get the first row (all)
  gapminder[, "country"] # select by name
  gapminder$country # slightly different
#+END_SRC
* Data import & manipulation
** Importing data
- We'll cover how to import rectangular data
- R can handle other types of data, but it's outside the scope of this class
- R has a lot of build in functions: =read.csv()=, =read.table()=, etc
- Packages provide still more: =readr::read_csv()=, =haven::read_dta()=, etc
- I prefer the =rio= package because I don't have to think
- Always gives you a =data.frame=:
#+BEGIN_SRC R :eval no
  library(rio)
  csv_data <- import("data/file.csv")
  stata_data <- import("data/file.dta")
#+END_SRC
** dplyr
- We are going to use dplyr, another package you've installed, to help us transform data
- The most super-useful dplyr functions:
- =filter()= drops rows based on columns
- =select()=  selects columns
- =mutate()=  creates new variables
- =summarize()= return statistics
- =group_by()= allows us to do the above by groups
-These functions take data as the first argument and always return a data.frame
#+BEGIN_SRC R
  library(dplyr)
#+END_SRC
** =filter=
- =filter()= uses logical statements (that are TRUE) to return rows:
#+BEGIN_SRC R
  filter(gapminder, continent == "Asia")
  filter(gapminder, continent == "Asia" & year >= 2000)
  filter(gapminder, continent == "Asia" & year != 2000)
  filter(gapminder, continent == "Asia" | year == 2000)
#+END_SRC
** Quiz
- Use filter to return all the rows containing observations from Asia or Africa
\pause
#+BEGIN_SRC R
  filter(gapminder, continent == "Asia" | continent == "Africa")
  filter(gapminder, continent %in% c("Asia", "Africa"))
#+END_SRC
** =select=
- The =select= function selects one or more columns:
#+BEGIN_SRC R
  select(gapminder, country)
  select(gapminder, country, year, continent)
  select(gapminder, -continent)
#+END_SRC
- several helper functions (e.g. =starts_with=), see =?select= for examples
** =mutate=
- Mutate creates new variables:
#+BEGIN_SRC R :exports both :results output
  mutate(gapminder, gdp = pop * gdpPercap)
#+END_SRC
** =summarize=
- =summarize= (or =summarise= if you prefer) creates summary statistics:
#+BEGIN_SRC R :exports both :results output
  summarize(gapminder, mean_life = mean(lifeExp))
#+END_SRC
** =group_by=
- All the functions we just learned can be performed by groups!
- This is really exciting and makes life much easier
- Calculate mean life expectancy by year:
#+BEGIN_SRC R
  summarize(group_by(gapminder, year), mean_life = mean(lifeExp))
  ## Or, to add it to the data:
  mutate(group_by(gapminder, year), year_mean_life = mean(lifeExp))
#+END_SRC
** =group_by=, continued
- You can group by multiple variables
- Calculate change in life expectancy by country:
#+BEGIN_SRC R
    mutate(group_by(gapminder, country),
           life_change = lifeExp - lag(lifeExp))
#+END_SRC
** Chaining
- What if we want to select all countries in Africa and calculate mean life expectancy by year?
- One option:
#+BEGIN_SRC R :eval no
  summarize(group_by(filter(gapminder,
                            continent == "Africa"),
                     year),
            mean_life = mean(lifeExp))
#+END_SRC
- Or we could assign to objects along the way
#+BEGIN_SRC R :eval no
  just_africa <- filter(gapminder,continent == "Africa"),
  africa_by_year <- group_by(just_africa, year)
  summarize(africa_by_year, mean_life = mean(lifeExp))
#+END_SRC
** Piping
- Both of those have downsides, though
- We'll use the /pipe/ =%>%= to "pipe" the thing on the left into the thing on the right:
#+BEGIN_SRC R :eval no
  gapminder %>%
    filter(continent == "Africa") %>%
    group_by(year) %>%
    summarize(meanlife = mean(lifeExp))
#+END_SRC
