#+TITLE:     Introduction to Data Analysis and Reporting with R
#+AUTHOR:    J. Alexander Branham
#+EMAIL:     branham@utexas.edu
#+DATE:      June 2017
#+startup: beamer
#+LaTeX_CLASS: beamer
#+LATEX_COMPILER: xelatex
#+OPTIONS: toc:nil H:2
#+LATEX_HEADER: \beamerdefaultoverlayspecification{<+->}
#+LATEX_HEADER: \usepackage[newfloat]{minted}
#+LATEX_CLASS_OPTIONS: [colorlinks, urlcolor=blue, aspectratio=169]
#+PROPERTY: header-args:R :session *R*
#+PROPERTY: header-args :tangle yes
#+BEAMER_THEME: metropolis[titleformat=smallcaps, progressbar=frametitle]
#+PROPERTY: header-args:R :results output
#+BEGIN_SRC R :exports none
  dir.create("figures/", showWarnings = FALSE)
  dir.create("tables/", showWarnings = FALSE)
#+END_SRC
#+BEGIN_EXPORT html
This is an html page so that it is easier to search and copy/paste. It won't include the figures and tables but should include all the relevant code.
#+END_EXPORT
* Course Information
** Course Information
- We'll cover tools that should be helpful in nearly any analysis
  - Graphing, data manipulation, etc
- We won't cover specialized, specific tools. But you should get a good enough understanding of how R works to be able to teach yourself these
** Outline
1. What is R?
2. Graphics
3. Basic R
4. Data manipulation
5. Reporting (time permitting)
* What is R?
** What is R?
- This is a course about R...  /mais qu'est-ce que c'est/?
- "R is a language and environment for statistical computing and graphics"
- Derived from S, designed at Bell Laboratories
  - S first appeared in 1976!
- /R is a language/ ... so be prepared for it to hurt a bit to learn!
** Advantages of R
#+LATEX: \pause
- Free
- Open-source
- Available on nearly every platform
- Extensible via *packages* --- CRAN has over 10,000
- Great community
** Running code
- How to use this R thing?
- If you have R and Rstudio installed, open Rstudio.
- You should see three panes.
- We'll focus for now on the console, which is on the left and should look something like this:
** The console
#+BEGIN_EXAMPLE
  R version 3.4.0 (2017-06-15) -- "You Stupid Darkness"
  Copyright (C) 2017 The R Foundation for Statistical Computing
  Platform: x86_64-pc-linux-gnu (64-bit)

  [ ... ]

  Type 'demo()' for some demos, 'help()' for on-line help, or
  'help.start()' for an HTML browser interface to help.
  Type 'q()' to quit R.

  >
#+END_EXAMPLE
** R is a big giant calculator
- R can do math
- Really, really fancy math
- Try typing =3 + 3= in the console
- After pressing enter, R will return =6=
- R understands the order of operations 
  - =3 + 3 * 9= is different from =(3 + 3) * 9=
** A quiz
- Time for a quiz!
- What's 7 times 149?
- What's the square root of the previous answer?
- *Tip:* You can hit the up arrow to get whatever you entered last
** Answers
#+BEGIN_SRC R :exports both :results output
7 * 149
#+END_SRC

#+BEGIN_SRC R :exports both :results output
(7 * 149) ^ (1 / 2)
#+END_SRC
** Packages
- At this point, please install a few packages. You'll need an internet connection.
- =install.packages(c("tidyverse", "gapminder"))=
  - If you have already installed some packages, make sure they're up-to-date:
    - =update.packages()=
- *Tip:* just type =ins= then hit TAB for tab-completion
- Don't worry about what is going on here, I'll explain it later.
- Depending on your exact setup, R may ask you a few questions about using a personal library. Do so.
- If you get an error, make sure you can access the internet (https://cloud.r-project.org in particular)
** R scripts
- While those packages are installing, let's go ahead and open up an R script.
- Allows you to save code so it doesn't disappear into the ether
- If using Rstudio, File, new file, R script (or Ctrl+shift+n)
- *Tip*: can send a line from R script to console for evaluation using ctrl+enter
- *Strongly recommend* that you type into a script and use a keyboard shortcut to evaluate code
  - Easier to edit & rerun
  - Allows you to save code
  - You may make comments
#+BEGIN_SRC R :eval no
  ## This adds 3 + 3
  3 + 3
  3 * 2 # same
#+END_SRC

* Graphics in R
** Data Analysis with R
- We need some data to work with
#+LATEX: \pause
- We're going to use some data that comes with the =gapminder= package you just installed
#+LATEX: \pause
- To access the data, you need to load it into memory:
#+BEGIN_SRC R
library(gapminder)
#+END_SRC
** Exploring our data
- =gapminder= is a *data.frame*
#+LATEX: \pause
- Can get a sense of what it looks like with some *functions*
#+LATEX: \pause
- Let's get a sense of what =gapminder= has:
#+BEGIN_SRC R :eval no
  View(gapminder)
#+END_SRC
#+LATEX: \pause
#+BEGIN_SRC R :exports both :results output
head(gapminder)
#+END_SRC
** Descriptive statistics
- R has lots of built-in functions for getting a sense of the data.
- Try running =summary(gapminder)=
- What's the average life expectancy?
#+LATEX: \pause
#+BEGIN_SRC R :exports both :results output
summary(gapminder)
#+END_SRC
** Graphics in R
- Let's start making graphs
- This is the fun part!
- We're going to rely on the `ggplot2` package, which we installed earlier (as a part of the tidyverse package)
- "The Grammar of Graphics"
- load it up with
#+BEGIN_SRC R
library(ggplot2)
#+END_SRC
** Our question
#+BEGIN_QUOTE
What's the relationship between wealth (gdp) and average life expectancy?
#+END_QUOTE
- Scatterplot is a good way to get started looking at data!
** ggplot2
- Use the =ggplot()= function to start a plot.
- The first /argument/ is to tell it the /data/
- *Tip:* use =?ggplot= to look at the help page, where you can see the names of the arguments
#+LATEX: \pause
#+BEGIN_SRC R :eval no
  ggplot(data = gapminder) # Please use gapminder data
#+END_SRC
** =geom_point=
- =ggplot()= by itself is pretty useless, it just starts a plot
- We then have to tell =ggplot= what to draw!
- *Tip:* =?geom_point=
#+LATEX: \pause
#+BEGIN_SRC R
    ggplot(data = gapminder) +
      geom_point(mapping = aes(x = gdpPercap, # Put gdp on x axis
                               y = lifeExp))  # Put lifeExp on y

#+END_SRC
#+BEGIN_SRC R :exports none
  ggsave("figures/gdp-life.pdf",
         width = 9,
         height = 6.5)
#+END_SRC

** 
#+ATTR_LATEX: :float t :width 0.8\textwidth
[[file:figures/gdp-life.pdf]]
** Fix that x axis!
- Is there a better way to show this relationship?
#+LATEX: \pause
#+BEGIN_SRC R
  ggplot(data = gapminder) +
    geom_point(mapping = aes(x = log(gdpPercap), # Log x-axis
                             y = lifeExp))
#+END_SRC
#+BEGIN_SRC R :exports none
  ggsave("figures/gdp-life-logx.pdf", width = 9, height = 6.5)
#+END_SRC
** 
#+ATTR_LATEX: :float t :width 0.8\textwidth
[[file:figures/gdp-life-logx.pdf]]
** Aesthetics
- =ggplot()= creates a coordinate system
#+LATEX: \pause
- You can then add one or more layers to this to create a plot
#+LATEX: \pause
- We just added the =geom_point()= layer, which used the =x= and =y= aesthetics (=aes=) to add a layer of points to our plot
#+LATEX: \pause
- We can add more information to the aesthetics to convey more information like color, shape, and size.
#+LATEX: \pause
- Example: What if we want to convey info about relationship between wealth and life expectancy by continent?
#+LATEX: \pause
- One solution: add color by continent
** Color 
#+BEGIN_SRC R
  ggplot(data = gapminder) +
    geom_point(mapping = aes(x = log(gdpPercap),
                             y = lifeExp,
                             ## colour for the Brits
                             color = continent)) 
#+END_SRC
#+BEGIN_SRC R :exports none
  ggsave("figures/gdp-life-continent-color.pdf",
         width = 9,
         height = 6.5)
#+END_SRC
** 
#+ATTR_LATEX: :float t :width 0.8\textwidth
[[file:figures/gdp-life-continent-color.pdf]]
** Multiple aesthetics - color & shape
- Of course, some people are colorblind, and others don't print things in color, so may be nice to use something like shape in addition:
#+LATEX: \pause

#+BEGIN_SRC R
  ggplot(gapminder) +
    geom_point(aes(x = log(gdpPercap),
                   y = lifeExp,
                   color = continent, 
                   shape = continent))
#+END_SRC
#+BEGIN_SRC R :exports none
  ggsave("figures/gdp-life-continent-shape.pdf",
         width = 9,
         height = 6.5)
#+END_SRC
** 
#+ATTR_LATEX: :float t :width 0.8\textwidth
[[file:figures/gdp-life-continent-shape.pdf]]
** More about aesthetics
- There are more aesthetic mappings
- Try =size=, and =alpha= (transparency) for yourself
#+LATEX: \pause
- You can set aesthetics directly by mapping the aesthetic to a value */outside/* the call to =aes()=
- For example, we may want to make the dots slightly transparent to avoid overplotting
** Aesthetics not mapped to variable
#+BEGIN_SRC R
  ggplot(data = gapminder) +
    geom_point(mapping = aes(x = log(gdpPercap),
                             y = lifeExp,
                             color = continent),
               alpha = 0.5)
#+END_SRC
#+BEGIN_SRC R :exports none
  ggsave("figures/gdp-life-transparent.pdf",
         width = 9,
         height = 6.5)
#+END_SRC

** 
#+ATTR_LATEX: :float t :width 0.8\textwidth
[[file:figures/gdp-life-transparent.pdf]]

** Facets
- So we can use aesthetics to add variables to our graph like =color=. 
- We might also want to add variables by splitting up the graph based on values of another variables --- e.g. subfigures
- If we want to use just one variable, use =facet_wrap()=
#+LATEX: \pause
#+BEGIN_SRC R
  ggplot(data = gapminder) +
    geom_point(mapping = aes(x = log(gdpPercap),
                             y = lifeExp)) +
    facet_wrap( ~ continent, nrow = 2)
#+END_SRC
#+BEGIN_SRC R :exports none
  ggsave("figures/gdp-life-facet-continent.pdf",
         width = 9,
         height = 6.5)
#+END_SRC
** 
#+ATTR_LATEX: :float t :width 0.8\textwidth
[[file:figures/gdp-life-facet-continent.pdf]]
** Facets with two variables
- ggplot can facet with two variables with one by row and the other by column
- Use =facet_grid(row ~ column)= to do so
- Our =gapminder= data aren't very well suited for this, but you could do something like:
#+LATEX: \pause
 #+BEGIN_SRC R
   ggplot(data = gapminder) +
     geom_point(mapping = aes(x = log(gdpPercap),
                              y = lifeExp)) +
     ## year >= 2000 will be TRUE or FALSE; 
     ## we'll learn more about logical statements later on:
     facet_grid(year >= 2000 ~ continent)  
#+END_SRC
#+BEGIN_SRC R :exports none
   ggsave("figures/gdp-life-facet-continent-post2000.pdf",
          width = 9,
          height = 6.5)
#+END_SRC
** 
#+ATTR_LATEX: :float t :width 0.8\textwidth
[[file:figures/gdp-life-facet-continent-post2000.pdf]]
** ggplot
#+LATEX: \pause
- Review of what we've learned so far:
  - =ggplot()= creates a blank coordinate system
#+LATEX: \pause
  - =aes()= helps us map variables to visual properties (x/y location, color, shape, etc)
#+LATEX: \pause
  - =facet_wrap()= and =facet_grid()= help us convey variables via subfigures
#+LATEX: \pause
- But what about plots other than the scatterplot?
** geoms
- A =geom= (geometrical object) is =ggplot='s way of representing data
#+LATEX: \pause
- We've been using =geom_point()= to represent data as points, e.g. a scatterplot
- A =geom= is (usually) the thing we call the plot - line plots, bar plots, boxplots, etc
#+LATEX: \pause
- Let's plot the same relationship between wealth and life expectancy but using =geom_smooth()= rather than =geom_point()=:
#+LATEX: \pause
#+BEGIN_SRC R
  ggplot(data = gapminder) +
    geom_smooth(mapping = aes(x = log(gdpPercap),
                              y = lifeExp)) 

#+END_SRC
#+BEGIN_SRC R :exports none
  ggsave("figures/gdp-life-smooth.pdf",
         width = 9,
         height = 6.5)
#+END_SRC
** 
#+ATTR_LATEX: :float t :width 0.8\textwidth
[[file:figures/gdp-life-smooth.pdf]]
** geoms
- Hey, that last plot looked pretty linear
- We can use OLS instead:
#+LATEX: \pause
#+BEGIN_SRC R
  ggplot(data = gapminder) +
    geom_smooth(mapping = aes(x = log(gdpPercap),
                              y = lifeExp),
                method = "lm")

#+END_SRC
#+BEGIN_SRC R :exports none
  ggsave("figures/gdp-life-smooth-lm.pdf",
         width = 9,
         height = 6.5)
#+END_SRC
** 
#+ATTR_LATEX: :float t :width 0.8\textwidth
[[file:figures/gdp-life-smooth-lm.pdf]]
** geoms and aesthetics
- Note that different aesthetics are available for different geoms
#+LATEX: \pause
- So while =linetype= didn't really make sense for our scatterplot, it makes total sense for a line:
#+LATEX: \pause
#+BEGIN_SRC R
  ggplot(data = gapminder) +
    geom_smooth(mapping = aes(x = log(gdpPercap),
                              y = lifeExp,
                              color = continent,
                              linetype = continent),
                method = "lm")

#+END_SRC
#+BEGIN_SRC R :exports none
  ggsave("figures/gdp-life-smooth-continent.pdf",
         width = 9,
         height = 6.5)
#+END_SRC
** 
#+ATTR_LATEX: :float t :width 0.8\textwidth
[[file:figures/gdp-life-smooth-continent.pdf]]
** multiple geoms
- To add multiple geoms, just add them one after the other:
#+LATEX: \pause
#+BEGIN_SRC R
  ggplot(data = gapminder) +
    geom_smooth(mapping = aes(x = log(gdpPercap),
                              y = lifeExp)) +
    geom_point(mapping = aes(x = log(gdpPercap),
                             y = lifeExp))


#+END_SRC
#+BEGIN_SRC R :exports none
  ggsave("figures/gdp-life-smooth-point.pdf",
         width = 9,
         height = 6.5)
#+END_SRC
** 
#+ATTR_LATEX: :float t :width 0.8\textwidth
[[file:figures/gdp-life-smooth-point.pdf]]
** inherit aes
- Instead of retyping the =aes= mapping, we can specify a set of defaults in the =ggplot()= call, and overwrite (or add) then in each =geom= call:
#+LATEX: \pause
#+BEGIN_SRC R
  ggplot(data = gapminder,
         mapping = aes(x = log(gdpPercap),
                       y = lifeExp)) +
    geom_smooth() +
    geom_point(mapping = aes(color = continent))
#+END_SRC
#+BEGIN_SRC R :exports none
  ggsave("figures/gdp-life-smooth-point-color.pdf",
         width = 9,
         height = 6.5)
#+END_SRC
** 
#+ATTR_LATEX: :float t :width 0.8\textwidth
[[file:figures/gdp-life-smooth-point-color.pdf]]
** Review
- ggplot2 provides a very flexible way to make high-quality graphics
- stuff we didn't look at:
  - Lots of different geoms
  - Changing scales
  - Position
  - How to save to include in your paper (later, I promise!)
* Basic R
** Basics
- We skipped all of this because plotting is more fun & I wanted to start with something fun 
- Let's talk about basic R
** Calculator
- Remember R can be a calculator:
#+BEGIN_SRC R :exports both :results output
  3 * 3 + 29 ^ 4 + 7
#+END_SRC
#+LATEX: \pause
- But R doesn't "remember" the answer to that anywhere
#+LATEX: \pause
- You must /assign/ the output to an object in order for R to remember it:
#+LATEX: \pause
#+BEGIN_SRC R
  x <- 3 * 3 + 29 ^ 4 + 7
  my_name <- "Alex Branham"
#+END_SRC
#+LATEX: \pause
- *Tip*: In Rstudio, use alt+- (option+-) to get =<-=
** Wait, what?
- Yeah, I just assigned letters to an object
#+LATEX: \pause
- We can inspect the contents of an object by typing it into the R console:
#+BEGIN_SRC R :exports both :results output
  x
#+END_SRC
#+LATEX: \pause
- Here, type =my_= then hit tab to have autocompletion
#+BEGIN_SRC R :exports both :results output
  my_name
#+END_SRC
** +
- If you forgot the closing ="= ---  =my_name <- "Alex Branham=
- The R prompt will change from =>= to =+=
- This indicates that R is waiting for you.
- Cancel by mashing ~ESC~
** R is pedantic
#+LATEX: \pause
- You have to be really specific with R:
#+BEGIN_SRC R :exports both :results output
x
#+END_SRC
#+LATEX: \pause
#+BEGIN_SRC R :exports both :results output
X
#+END_SRC
#+LATEX: \pause
#+BEGIN_SRC R :exports both :results output
my_nam
#+END_SRC
** Things don't happen magically
#+BEGIN_SRC R :exports both :results output
x
#+END_SRC
#+BEGIN_SRC R :exports both :results output
x / 1000
#+END_SRC
#+LATEX: \pause
#+BEGIN_SRC R :exports both :results output
x
#+END_SRC
** Missing values
- Missing data is represented by =NA= in R
- R thinks about this as "something that's there, but whose value we do not know"
- Missingness propagates
#+LATEX: \pause
#+BEGIN_SRC R :exports both :results output
  mean(c(1, 2, NA))
#+END_SRC
** Missingness quiz
- What will be the result?
- We'll learn more about logical statements in a bit, this asks "Is 3 equal to NA"?
#+BEGIN_SRC R :eval no
  3 == NA
  NA == NA
#+END_SRC
** Missingness quiz answer
#+BEGIN_SRC R :exports both :results output
  3 == NA
#+END_SRC
#+BEGIN_SRC R :exports both :results output
  NA == NA
#+END_SRC
** Functions
- Functions in R can take zero or more arguments
#+BEGIN_EXAMPLE
  function(arg1 = object1, arg2 = object2, arg3 = object3)
#+END_EXAMPLE
#+LATEX: \pause
#+BEGIN_SRC R :exports both :results output
  my_vector <- seq(from = 1, to = 10, by = 1)
  my_vector
#+END_SRC
#+LATEX: \pause
#+BEGIN_SRC R :exports both :results output
  mean(x = my_vector)
#+END_SRC
** Functions, continued
#+BEGIN_SRC R :exports both :results output
  my_vector <- c(1, 2, 3, NA, NA, NA, 3, 2, 1)
  mean(x = my_vector)
#+END_SRC
#+LATEX: \pause
#+BEGIN_SRC R :exports both :results output
  mean(x = my_vector, na.rm = TRUE)
#+END_SRC
** Function arguments
- You don't have to specify argument names if you type them in order.
- Since =x= is the first argument of =mean()=, no need to type =mean(x = my_vector)=
- Instead, can just type =mean(my_vector)=
- This cuts down on the amount you have to type
** Data
- OK, so now we know how to assign stuff and functions
- Let's learn about how R thinks about data
  - "data" here doesn't have to mean data from e.g. a survey
- R cares about the *class* (type) of data and its *dimension(s)*
** Data types
- We'll discuss the four most common data types:
  - Numeric
  - Logical
  - Character
  - Factor
- We'll also cover =NA=
** Numeric
- Numeric is how R thinks about numbers!
- These can also be called "integer" (if round numbers) or "double"
#+BEGIN_SRC R :exports both :results output
  class(c(1, 2, 3))
#+END_SRC
#+LATEX: \pause
#+BEGIN_SRC R :exports both :results output
  sum(c(1, 2, 3))
#+END_SRC
#+LATEX: \pause
#+BEGIN_SRC R :exports both :results output
  class(sum(c(1, 2, 3)))
#+END_SRC
** Logical
- Logical can take two values --- =TRUE= or =FALSE=
#+LATEX: \pause
- This is useful for dummy variables and tests
#+LATEX: \pause
#+BEGIN_SRC R :exports both :results output
  1:10 > 5
#+END_SRC
** Character
- Characters represent text
- Sometimes these are called "strings"
#+BEGIN_SRC R
  c("This", "vector", "is", "of", "length", "what?")
  c("How about this one?")
#+END_SRC
** Factor
- Factors are how R thinks about categorical variables
#+LATEX: \pause
- We already worked with these when we used the =continent= variable from =gapminder=
#+LATEX: \pause
#+BEGIN_SRC R :exports both :results output
  head(gapminder$continent)
#+END_SRC
** Data type quiz
What type of data are the following?
#+BEGIN_SRC R
  182
  c("My name is Alex")
  "TRUE"
  FALSE
  c(1, 2, 3)
  c(1, "Alex", TRUE)
#+END_SRC
** Data dimensions
What's the difference?
#+BEGIN_SRC R :results output :exports results
  c(1, 2, 3, 4, 5, 6)
#+END_SRC
#+BEGIN_SRC R :results output :exports results
  matrix(c(1, 2, 3, 4, 5, 6), nrow = 3)
#+END_SRC
#+LATEX: \pause
- Data can have *dimensions*
- Numeric, logical, character, and factors are single dimensions (so are lists)
#+LATEX: \pause
- That matrix is a 3 by 2 matrix
- Why might we want to have two-dimensional data?
** The data.frame
- Matrices must have the same type, but we can mix and match types with a =data.frame=
- Remember =gapminder= from earlier?
- We used a =data.frame= to store columns with different data types
#+LATEX: \pause
- We can access (index, subset) =data.frame= objects using notation similar to matrix notation:
** Indexing data.frame
#+BEGIN_SRC R :eval no
  gapminder[2, 1] # get whatever is in the second row, 1st col
  gapminder[1, ]  # get the first row (all)
  gapminder[, 1]  # get the first col (all)
  gapminder[, "country"] # select by name
  gapminder$country # slightly different
#+END_SRC
** Review
- What we learned
- Missingness propagates
- Functions & arguments
- Basic vectors: numeric, logical, character, factor
- Dimensions & the data.frame
* Data import & manipulation
** Importing data
- Importing data in R is either trivially easy (usually) or super specific and difficult (rarely), so we won't actually be doing this
#+LATEX: \pause
- R has a lot of build in functions: =read.csv()=, =read.table()=, etc
- Packages provide still more: =readr::read_csv()=, =haven::read_dta()=, etc
#+LATEX: \pause
- I prefer the =rio= package because I don't have to think
- Always gives you a =data.frame=:
#+BEGIN_SRC R :eval no
  library(rio)
  csv_data <- import("file.csv")
  stata_data <- import("file.dta")
#+END_SRC
** Working directories & project structure
- R has the concept of a "working directory"
- You can see where this is by typing =getwd()= into the console
- I like to store data and code in separate folders:
- *Tip*: Rstudio can manage "projects" that take care of a lot of this
** Simple project structure
#+BEGIN_EXAMPLE
  my-paper-project/
  |--- code/
  |    |--- my-script.R
  |    |--- my-alt-script.R
  |--- data/
  |    |--- awesome-data.csv
  |--- output/
  |    |--- figure1.eps
  |    |--- figure2.eps
  |    |--- table1.tex
  |    |--- table2.tex
  |--- my-paper.tex
#+END_EXAMPLE
** Relative paths
- If you have code like that, you need to know what a relative path is so that code in your ~code/~ directory can load data in your ~data/~ directory!
#+LATEX: \pause
- So if we're running a file from ~code/~ (that's the working directory), we can load data by doing:
#+BEGIN_SRC R :eval no
  my_awesome_data <- import("../data/awesome_data.csv")
#+END_SRC
#+LATEX: \pause
- Two dots =..= says "go up one directory", we could chain them to go up two: =../..=
** dplyr
- We are going to use dplyr, another package you've installed, to help us transform data
#+LATEX: \pause
- =filter()= drops rows based on columns
- =select()=  selects columns
#+LATEX: \pause
- =mutate()=  creates new variables
- =summarize()= return statistics
#+LATEX: \pause
- =group_by()= allows us to do the above by groups
#+LATEX: \pause
-These functions take data as the first argument and always return a data.frame[fn:1]
#+BEGIN_SRC R
  library(dplyr)
#+END_SRC
** =filter=
- =filter()= uses logical statements (that are TRUE) to return rows:
#+BEGIN_SRC R
  filter(gapminder, continent == "Asia")
  filter(gapminder, continent == "Asia" & year >= 2000)
  filter(gapminder, continent == "Asia" & year != 2000)
  filter(gapminder, continent == "Asia" | year == 2000)
#+END_SRC
** Quiz
- Use filter to return all the rows containing observations from Asia or Africa
#+LATEX: \pause
#+BEGIN_SRC R
  filter(gapminder, continent == "Asia" | continent == "Africa")
  filter(gapminder, continent %in% c("Asia", "Africa"))
#+END_SRC
** =select=
- The =select= function selects one or more columns:
#+BEGIN_SRC R
  select(gapminder, country)
  select(gapminder, country, year, continent)
  select(gapminder, -continent)
#+END_SRC
- several helper functions (e.g. =starts_with=), see =?select= for examples
** =mutate=
- Mutate creates new variables:
#+BEGIN_SRC R :exports both :results output
  mutate(gapminder, gdp = pop * gdpPercap)
#+END_SRC
** =summarize=
- =summarize= (or =summarise= if you prefer) creates summary statistics:
#+BEGIN_SRC R :exports both :results output
  summarize(gapminder, mean_life = mean(lifeExp))
#+END_SRC
#+LATEX: \pause
- Though whoop-de-doo, we could've just done =mean(gapminder$lifeExp)= to get that!
#+LATEX: \pause
- Much more useful if we do this by groups
** =group_by=
- All the functions we just learned can be performed by groups!
- This is really exciting and makes life much easier
- Calculate mean life expectancy by year:
#+LATEX: \pause
#+BEGIN_SRC R :results output :exports both
  summarize(group_by(gapminder, year), mean_life = mean(lifeExp))
  ## Or, to add it to the data:
  mutate(group_by(gapminder, year), year_mean_life = mean(lifeExp))
#+END_SRC
** =group_by=, continued
- Calculate change in life expectancy by country:
#+LATEX: \pause
#+BEGIN_SRC R :results output :exports both
    mutate(group_by(gapminder, country),
           life_change = lifeExp - lag(lifeExp))
#+END_SRC
** =group_by=, continued
- You can group by multiple variables
#+BEGIN_SRC R :results output :exports both
  summarize(group_by(gapminder, continent, year),
            mean_life = mean(lifeExp))
#+END_SRC
** Chaining
- What if we want to select all countries in Africa and calculate mean life expectancy by year?
#+LATEX: \pause
- This is easy to do because the dplyr functions always take the data as their first argument and always return a data.frame
** Chaining, continued
#+LATEX: \pause
- One option:
#+BEGIN_SRC R :eval no
  summarize(group_by(filter(gapminder,
                            continent == "Africa"),
                     year),
            mean_life = mean(lifeExp))
#+END_SRC
#+LATEX: \pause
- Or we could assign to objects along the way
#+BEGIN_SRC R :eval no
  just_africa <- filter(gapminder,continent == "Africa"),
  africa_by_year <- group_by(just_africa, year)
  summarize(africa_by_year, mean_life = mean(lifeExp))
#+END_SRC
** Piping
- Both of those have downsides, though
#+LATEX: \pause
- We'll use the /pipe/ =%>%= to "pipe" the thing on the left into the thing on the right:
- *Tip:* In Rstudio, use Ctrl+shift+m (Cmd+shift+m) to get =%>%=
#+LATEX: \pause
#+BEGIN_SRC R :eval no
  gapminder %>%
    filter(continent == "Africa") %>%
#+END_SRC
#+LATEX: \pause
#+BEGIN_SRC R :eval no
    group_by(year) %>%
#+END_SRC
#+LATEX: \pause
#+BEGIN_SRC R :eval no
    summarize(meanlife = mean(lifeExp))
#+END_SRC
** Quiz
- Create a data.frame containing the continent, year, avg life expectancy, and change in avg life expectancy
** Quiz answers
#+BEGIN_SRC R :exports both :results output
  gapminder %>%
    group_by(continent, year) %>%
    summarize(avg_life = mean(lifeExp)) %>%
    mutate(change_life = avg_life - lag(avg_life))
#+END_SRC
** Ungrouping
- Note that our answer had "continent" as a group
- It's easy to forget about this, so if you're saving the object for use later, you may want to run =ungroup()= to undo the grouping on the data.frame.
** Other data manipulation
- Those commands take care of the most common data manipulation tasks
- There's tons more but we don't have the time to go over them all
- Search engines and R's help are your friend
** Review
- We learned how to use some of the most common =dplyr= functions to manipulate data (filter, select, mutate, summarize)
- =group_by= makes doing this by groups super easy
- Piping can make it easier to read code
* Diamonds
** The diamonds dataset
- We just learned a lot, let's apply some of it to a new dataset
- I'm also going to switch from this powerpoint to a "live demo!"
#+BEGIN_SRC R :eval no :exports none
  library(tidyverse)

  head(diamonds)
  summary(diamonds)
  ## View(diamonds)

  ## Look at counts of diamonds by cut quality

  ggplot(diamonds, aes(cut)) +
    geom_bar()

  ## Oftentimes want to add color:

  ggplot(diamonds, aes(cut, color = cut)) +
    geom_bar()

  ## But need to use fill:

  ggplot(diamonds, aes(cut, fill = cut)) +
    geom_bar()

  ## Might want to fill based on another variable:

  ggplot(diamonds, aes(cut, fill = clarity)) +
    geom_bar()

  ## Defaults to stacking, which you may not want

  ## Can adjust "position" to what you want:

  ggplot(diamonds, aes(cut, fill = clarity)) +
    geom_bar(position = "dodge")

  ggplot(diamonds, aes(cut, fill = clarity)) +
    geom_bar(position = "fill")

  ## Look at the price by cut
  ggplot(diamonds, aes(cut, price)) +
    geom_boxplot()


  ## Flip coordinate
  ggplot(diamonds, aes(cut, price)) +
    geom_boxplot() +
    coord_flip()


  ## What if we calculate the mean price and want to put it in the graph
  ## ourselves?

  diamonds %>%
    group_by(cut) %>%
    summarize(mean = mean(price)) %>%
    ggplot(aes(cut, mean,
               color = cut)) +
    geom_bar()
#+END_SRC

* Reporting from R
** Reporting
- We've learned most of what you need to do data analysis!
- Now let's do a new analysis on how to report, so we'll learn
  - How to report
  - Review much of what we learned
  - Learn a few more tricks and tips
- Right now is a good time to "restart" R and to make a project
- I put mine in =~/research/awesome-paper/= but you can put yours wherever!
** New data
- Let's change the dataset we're using, just for something new:
- We'll use the =midwest= dataset from =ggplot2=, which has info on some U.S. midwest counties:
#+BEGIN_SRC R
  library(tidyverse)
  midwest
#+END_SRC
** Descriptive statistics
- Let's look at the relationship between college education and the percent living in poverty. And maybe this looks different in metro areas, so let's keep that in mind too.
#+LATEX: \pause
- I always like to show some descriptive statistics
- Find the mean and standard deviation of our three variables!
#+LATEX: \pause
#+BEGIN_SRC R
  midwest %>%
    select(percbelowpoverty, percollege, inmetro) %>%
    summarize_all(funs(mean, sd))
#+END_SRC

** Functions
- What if we want another function other than mean, sd, etc?
- Very likely that it's either in base R or someone has written it
- Or you can write a function yourself!
- This is actually really easy in R
** Custom functions
- Let's pretend R didn't have a =mean= function
- How would we write it?
- What do we need to find?
#+LATEX: \pause
$$ \frac{1}{n} \sum x  $$
#+LATEX: \pause
#+BEGIN_SRC R :eval no
  sum(x) / length(x)
#+END_SRC
** Custom functions
#+BEGIN_SRC R :exports both
  my_mean <- function(x){
    sum(x) / length(x)
  }
  my_mean(-1:10)
#+END_SRC
#+LATEX: \pause
But what about NA???
** If statements
- An =if= statement allows us to conditionally execute code
#+BEGIN_SRC R :eval no
  my_name <- "Alex"
  if (my_name == "Alex"){
    print("I'm Alex!!!")
  } else{
    print("You aren't Alex!!!")
  }
#+END_SRC
** Back to the NA problem
How to modify our function???
#+BEGIN_SRC R
  my_mean <- function(x){
    sum(x) / length(x)
  }
#+END_SRC
#+LATEX: \pause
- *Solution:* Use an if statement! But we gotta let the user tell us whether to remove NA...
** Arguments and defaults
#+BEGIN_SRC R
  my_mean <- function(x, na.rm = FALSE){
    if(na.rm){ x <- x[!is.na(x)]}
    sum(x) / length(x)
  }
#+END_SRC
** Test your functions
Always test a function to make sure it works!
#+BEGIN_SRC R
  my_mean(c(NA, 0, 1), TRUE)
  my_mean(c(NA, 0, 1), FALSE)
#+END_SRC
** Back to our regularly scheduled program...
#+BEGIN_SRC R :eval no
  midwest %>%
    select(percbelowpoverty, percollege, inmetro) %>%
    summarize_all(funs(mean, sd))
#+END_SRC
#+LATEX: \pause
- But what if we want to show that in our paper?
** stargazer
#+LATEX: \pause
- There are several packages that let you easily make \LaTeX\nbsp{}tables, let's use =stargazer=:
#+BEGIN_SRC R
  library(stargazer)
#+END_SRC
- Can handle Word too, need to do an html dance. See package docs.
** Descriptive stats, latex table:
# Here there's a trick: I want to show relative paths using the dir structure
# from before, but that's not what I'm *actually* using
#+BEGIN_SRC R :eval no :exports both :results output
  midwest %>%
    select(percbelowpoverty, percollege, inmetro) %>%
    ## stargazer is picky about tibbles vs data.frames
    as.data.frame %>%
    stargazer(out = "../output/desc-stats.tex",
              title = "Descriptive Statistics")
#+END_SRC
#+BEGIN_SRC R :exports none
  midwest %>%
    select(percbelowpoverty, percollege, inmetro) %>%
    as.data.frame %>%
    stargazer(out = "tables/desc-stats.tex",
              title="Descriptive Statistics")
#+END_SRC
** Descriptive stats, latex table result
- use =\input{output/desc-stats.tex}= to import the table into your paper
#+BEGIN_EXPORT latex
\input{tables/desc-stats.tex}
#+END_EXPORT
** Plot 1
- Let's make a scatterplot!
#+LATEX: \pause
- Make a scatterplot with =percbelowpoverty= on the y-axis and include info on =percollege= and =inmetro=

** Plot 1, simple
#+BEGIN_SRC R
  g <- midwest %>%
    ## inmetro is a number but needs to be discrete.
    ## as.logical will convert so that a 0 is FALSE
    mutate(inmetro = as.logical(inmetro)) %>%
    ggplot(aes(percbelowpoverty, percollege,
               color = inmetro,
               shape = inmetro)) +
    geom_point()
#+END_SRC
#+BEGIN_SRC R :exports none
  g
  ggsave("figures/my-plot1-simple.pdf",
         width = 9, height = 6.5)
#+END_SRC
** 
#+ATTR_LATEX: :float t :width 0.8\textwidth
[[file:figures/my-plot1-simple.pdf]]
** More about graphs
- Note that I assigned the plot to an object =g=
- We might want to change some more stuff about the graph (legends, assign colors, etc)
- This way I don't have to re-run the same code
** Adjust the scale
- You may want to change the color, label legends, etc
- use =scale_aes_type= to do so
- So, for example, we can do =scale_color_manual= to change the properties of the color scale.
- Let's change it so that metro areas are blue and rural areas are red:
#+BEGIN_SRC R
  ## Plain red is super harsh, let's scale it back a bit:
  g + scale_color_manual(values = c("red3", "blue"))
#+END_SRC
#+BEGIN_SRC R :exports none
  g + scale_color_manual(values = c("red3", "blue"))
  ggsave("figures/my-plot1-color.pdf",
         width = 9, height = 6.5)
#+END_SRC
** 
#+ATTR_LATEX: :float t :width 0.8\textwidth
[[file:figures/my-plot1-color.pdf]]
** Changing legend labels
- Of course, =FALSE= and =TRUE= are not good legend labels. We can change those too with the =scale_color_manual= command:
#+BEGIN_SRC R
  g + scale_color_manual(values = c("red3", "blue"),
                         labels = c("Rural", "Urban"))
#+END_SRC
#+BEGIN_SRC R :exports none
  g + scale_color_manual(values = c("red3", "blue"),
                         labels = c("Rural", "Urban"))
  ggsave("figures/my-plot1-scales.pdf",
         width = 9, height = 6.5)
#+END_SRC
** 
#+ATTR_LATEX: :float t :width 0.8\textwidth
[[file:figures/my-plot1-scales.pdf]]
** UGHHHHHHHHH
- Now the legends are separate, though. Need to tell the shape aesthetic to use the same labels!
- While we're at it, let's remove the legend title (name):
- Since we're done changing the scales, let's reassign =g=
#+BEGIN_SRC R
  g <- g + scale_color_manual(values = c("red3", "blue"),
                             labels = c("Rural", "Urban"),
                             name = "") +
    scale_shape_discrete(labels = c("Rural", "Urban"),
                         name = "")
#+END_SRC
#+BEGIN_SRC R :exports none
  g <- g + scale_color_manual(values = c("red3", "blue"),
                             labels = c("Rural", "Urban"),
                             name = "") +
    scale_shape_discrete(labels = c("Rural", "Urban"),
                         name = "")
  ggsave("figures/my-plot1-scales2.pdf",
         width = 9, height = 6.5)
#+END_SRC
** 
#+ATTR_LATEX: :float t :width 0.8\textwidth
[[file:figures/my-plot1-scales2.pdf]]
** Axis labels
- We should probably fix up our axis labels
- Note that if you want to give the plot a title, subtitle, or caption, you may do so here
#+BEGIN_SRC R
  g <- g + labs(x = "Percent below poverty",
               y = "Percent with a college degree")
#+END_SRC
#+BEGIN_SRC R :exports none
  g
  ggsave("figures/my-plot1-labs.pdf",
         width = 9, height = 6.5)
#+END_SRC
** 
#+ATTR_LATEX: :float t :width 0.8\textwidth
[[file:figures/my-plot1-labs.pdf]]
** Background and themes
- I'm not a fan of the default grey background.
- You can adjust everything yourself, but there are several themes that come built-in
- The package =ggthemes= has many other themes
- You can make it look like you're graphing for the economist. Or from Stata
** Much themes, wow
#+BEGIN_SRC R
  g + theme_grey()
  g + theme_gray()
  g + theme_bw()
  g + theme_linedraw()
  g + theme_light()
  g + theme_dark()
  g + theme_minimal()
  g + theme_classic()
  g + theme_void()
#+END_SRC
** Plot 1, full
#+BEGIN_SRC R
  midwest %>%
    select(percbelowpoverty, percollege, inmetro) %>%
    mutate(inmetro = as.logical(inmetro)) %>%
    ggplot(aes(percbelowpoverty, percollege,
               color = inmetro,
               shape = inmetro)) +
    geom_point() +
    scale_color_manual(values = c("red3", "blue"), labels = c("Rural", "Urban"),
                       name = "") +
    scale_shape_discrete(labels = c("Rural", "Urban"), name = "") +
    labs(y = "Percent below poverty line",
         x = "Percent with a college education") +
    theme_bw()
#+END_SRC
#+BEGIN_SRC R :exports none
  ggsave("figures/my-plot1-themed.pdf",
         width = 9, height = 6.5)
#+END_SRC
** 
#+ATTR_LATEX: :float t :width 0.8\textwidth
[[file:figures/my-plot1-themed.pdf]]
** How to save ggplots
- The =ggsave= function saves a plot (by default, the last one you plotted)
- It's important to specify the width and height
#+BEGIN_SRC R :eval no
  ggsave("../output/my-scatterplot.eps",
         ## Important to specify!!!
         width = 9, height = 6.5)
#+END_SRC
#+BEGIN_SRC R :exports none
  ggsave("figures/my-scatterplot.pdf",
         ## Important to specify!!!
         width = 9, height = 6.5)
#+END_SRC

** Linear regression
- Let's run a linear predicting poverty with education and include an interaction term for inmetro
  - Yes, I'm ignoring all kinds of issues with this particular model
 #+BEGIN_SRC R
   my_reg <- lm(percbelowpoverty ~ percollege * inmetro,
               data = midwest)
   summary(my_reg)
 #+END_SRC

** Linear regression table
#+BEGIN_SRC R :eval no
  stargazer(my_reg,
            out = "../output/my-reg.tex")
#+END_SRC
#+BEGIN_SRC R :exports none
  stargazer(my_reg,
            font.size = "tiny", 
            out = "tables/my-reg.tex")
#+END_SRC
#+LATEX: \pause
- Use =\input{output/my-reg.tex}= in your \LaTeX\nbsp{} document to import the table!
** 
#+BEGIN_EXPORT latex
\input{tables/my-reg.tex}
#+END_EXPORT
** Multiple models
- Oftentimes, we want multiple models
- You can, of course, copy paste code, but that's error prone (typos, ugh), and difficult to change later on
- There's an easy solution for this, but first let's talk about a data structure we haven't mentioned much yet:
#+LATEX: \pause
#+LATEX: \huge
THE LIST
** Lists
- A list is one dimensions (like numeric, logical, character, factor)
#+LATEX: \pause
- But each element can be of a different type
#+LATEX: \pause
- We can create lists with the =list= command
- Look at the difference:
** Lists, continued
#+BEGIN_SRC R :exports both :results output
  c(3, TRUE, "Nancy")
#+END_SRC
#+BEGIN_SRC R :exports both :results output
  list(3, TRUE, "Nancy")
#+END_SRC
** Lists, more
- Subsetting lists can be a little weird
- We use =[[=  or =[= to subset
- First, create a list:
#+BEGIN_SRC R
  x <- list(c(1:10),
           c(TRUE, NA, TRUE),
           c("Bob", "Alice", "Nancy", "Drew"))
#+END_SRC
** Subsetting lists
- What is the difference:
#+BEGIN_SRC R
  x[[1]]
  x[1]
#+END_SRC
** Named lists
- The double bracket contains the thing at the position, 
- Single bracket returns a list of the thing at the position 
- Elements of a list can have names:
#+BEGIN_SRC R
  names(x) <- c("nums", "logs", "chars")
  ## Can also specify at creation time e.g. list(nums = 1:10) etc
#+END_SRC
** Named lists, continued
#+BEGIN_SRC R :exports both :results output
  x
#+END_SRC
** Subsetting named lists
- We can now access elements of the list by name instead of by position:
#+BEGIN_SRC R :exports both
  x$chars
#+END_SRC
** Data frames are lists too!
- Remember we can use =dataframe$varname= to access variables from a data frame?
#+LATEX: \pause
- Does this look similar to what we just did with lists?
#+LATEX: \pause
- That's because data frames are secretly lists themselves!
** Back to modeling
- OK, why did we just learn about lists?
#+LATEX: \pause
- We were modeling percent below poverty with an interaction between college education and metro area status
#+LATEX: \pause
- What if we want to "build the model" by including constituent variables one at a time?
- One way:
** Multiple models
#+BEGIN_SRC R
  model1 <- lm(percbelowpoverty ~ percollege, data = midwest)
  model2 <- lm(percbelowpoverty ~ inmetro, data = midwest)
  model3 <- lm(percbelowpoverty ~ percollege * inmetro, data = midwest)
#+END_SRC
** Multiple models
- But if we do that, we now have three models just floating around.
- To get summary measures:
#+LATEX: \pause
#+BEGIN_SRC R
  summary(model1)
  summary(model2)
  summary(model3)
#+END_SRC
** Multiple models
Y-hats:
#+BEGIN_SRC R
  predict(model1)
  predict(model2)
  predict(model3)
#+END_SRC
** The problem
- That's just with three models!
- Sometimes we run many more and the problem only gets worse!
#+LATEX: \pause
- *Idea!* let's use the list to make life easier!
** Multiple models with a list
#+BEGIN_SRC R
  my_formulae <- list(model1 = percbelowpoverty ~ percollege,
                     model2 = percbelowpoverty ~ inmetro,
                     model3 = percbelowpoverty ~ percollege * inmetro)
#+END_SRC
** Run the models!
- Base R provides =lapply= which iterates over lists
#+BEGIN_SRC R
  my_regs <- lapply(my_formulae,
                   function(l_ele){lm(l_ele, data = midwest)})
#+END_SRC
- First argument is a list, second is a function to apply to each element of the list
- We use an /anonymous function/ - one that we create on the fly. You could've created a named function too like we did with =my_mean= previously
** Run the models!
- I don't really like that syntax though so I use =map= from the =purrr= package.
- This will do the same thing; the tilde magically creates an anonymous function in the background
#+BEGIN_SRC R
  my_regs <- map(my_formulae, ~ lm(.x, data = midwest))
#+END_SRC
** Summarize the models
#+BEGIN_SRC R
  map(my_regs, summary)
#+END_SRC
** Get predicted values
#+BEGIN_SRC R
  map(my_regs, predict)
#+END_SRC
** Get residuals
#+BEGIN_SRC R
  map(my_regs, residuals)
#+END_SRC
** Broom
The broom package has three functions that turns models into data.frames:
1. =glance()= returns a row with model quality/complexity
2. =tidy()= returns a row for each coefficient
3. =augment()= returns a row for every row in the data, adding some values (usually residuals and the like)
** Get fit statistics
#+BEGIN_SRC R :eval no
  map(my_regs, broom::glance)
#+END_SRC
** broom::tidy
#+BEGIN_SRC R :eval no
  map(my_regs, broom::tidy)
#+END_SRC
** broom::augment
#+BEGIN_SRC R :eval no
  map(my_regs, broom::augment)
#+END_SRC
** Reporting multiple models
- The stargazer function is smart enough to figure out multiple models:
#+BEGIN_SRC R :eval no
  stargazer(my_regs,
            out = "../output/my-reg.tex")
#+END_SRC
#+BEGIN_SRC R :exports none
  stargazer(my_reg,
            font.size = "tiny", 
            out = "tables/my-reg.tex")
#+END_SRC
** 
#+BEGIN_EXPORT latex
\input{tables/my-reg.tex}
#+END_EXPORT
** Plotting predicted values
- We usually want to plot the predicted values from our models
- We'll keep using a linear model, but this can really be anything
- Let's say we want to compare how adding the interaction term affects our predictions
- One way: Plot predicted values from our first and third regressions!
- Let's add them to our data.frame
** Getting predicted values
#+BEGIN_SRC R
  my_midwest <- midwest
  my_midwest$pred_m1 <- predict(my_regs$model1)
  my_midwest$pred_m3 <- predict(my_regs$model3)
#+END_SRC
** Generate plots
#+BEGIN_SRC R
  ggplot(my_midwest,
         aes(percollege)) +
    geom_line(aes(y = pred_m1)) +
    geom_line(aes(y = pred_m3,
                  linetype = as.logical(inmetro)),
              color = "blue")
#+END_SRC
#+BEGIN_SRC R :exports none
  ggsave("figures/predictions.pdf",
         ## Important to specify!!!
         width = 9, height = 6.5)
#+END_SRC
** 
#+ATTR_LATEX: :float t :width 0.8\textwidth
[[file:figures/predictions.pdf]]
** Merging 
- Let's talk about merging data!
- Oftentimes we have different datasets that we need to merge together for whatever reason
- dplyr refers to "merging" as "joining," which is language borrowed from SQL
- Let's go to another "live demo"
- Let's look at two toy datasets that come with dplyr
#+BEGIN_SRC R :eval no
  library(tidyverse)

  band_members

  band_instruments

  ##  Joining
  ## - dplyr thinks about the two datasets as "x" (on the left) and "y" (on the right)
  ## - We can use joins to add columns based on shared values
  ## - Four basic uses:
  ##   - =full_join()= keeps everything from x and y
  ##   - =left_join= keeps everything from x
  ##   - =right_join= keeps everything from y
  ##   - =inner_join= returns only matching rows


  full_join(band_members, band_instruments)
  left_join(band_members, band_instruments)
  right_join(band_members, band_instruments)
  inner_join(band_members, band_instruments)

  ## - By default, dplyr will join the datasets based on all the shared column names
  ## - What if we have different column names?

  band_members
  band_instruments2


  ## - One solution: rename the columns in one data frame so they're the same:

  rename(band_instruments2, name = artist)


  ## Another solution: tell dplyr this info during the join

  full_join(band_members, band_instruments2,
            by = c("name" = "artist"))
#+END_SRC

** How to get help
- Stack overflow (but have an MRE)
- Twitter (#rstats)
- Me! (branham@utexas.edu)
** Other tools that work well with R
- Git
- \LaTeX
- (r)markdown
** 
:PROPERTIES:
:BEAMER_OPT: label=thanks,standout
:END:
Thanks for coming!
* Footnotes

[fn:1] Technically, a =tibble=, but the difference isn't very much, so we'll ignore that
